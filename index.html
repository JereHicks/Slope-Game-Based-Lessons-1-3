<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rowboat Slope Adventure — Levels 1–3 (Final)</title>
<style>
  :root{--bg1:#e8fbff;--bg2:#d0f7ff;--muted:#134a55;--accent:#0ea5e9;--warn:#b45309;--good:#0b9c6b}
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg1),var(--bg2));font-family:Inter,system-ui,Arial;color:var(--muted)}
  .wrap{max-width:1100px;margin:14px auto;padding:12px}
  header{display:flex;align-items:center;justify-content:space-between}
  h1{margin:6px 0;font-size:24px;color:#04323a}
  .meta{color:#28535e;font-size:13px}
  .panel{background:#fff;padding:12px;border-radius:12px;border:1px solid rgba(6,50,60,0.04);margin-top:12px}
  #gridWrap{border-radius:12px;overflow:hidden;margin-top:12px;display:flex;justify-content:center}
  canvas{display:block;background:transparent;outline:none}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .btn{padding:8px 12px;border-radius:8px;border:1px solid #e6eef8;background:white;cursor:pointer}
  .small{font-size:13px;color:#395a61}
  #directions{font-weight:700;color:#063b46}
  #bullets{margin-top:8px}
  #hint{color:var(--warn);margin-top:6px;min-height:18px}
  #result{margin-top:10px;padding:10px;border-radius:10px;display:none;font-weight:700}
  #result.good{background:linear-gradient(#ecfdf5,#dff6ed);color:var(--good);border:1px solid #baf0d0}
  .stars{display:flex;gap:6px}
  .star{width:28px;height:28px;opacity:0.25}
  .star.filled{opacity:1;filter:drop-shadow(0 3px 6px rgba(2,12,28,0.12))}
  footer{margin-top:12px;text-align:center;font-size:13px;color:#385b62}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Rowboat Slope Adventure</h1>
        <div class="meta">Use the arrow keys on your keyboard to move the boat using rise (vertical) then run (horizontal) to reach the island.</div>
      </div>
      <div style="text-align:right">
        <div class="small">Level: <span id="levelBadge">1</span></div>
        <div class="stars" title="Progress this level">
          <svg id="s1" class="star" viewBox="0 0 24 24"><path fill="#f6c200" d="M12 .587l3.668 7.431L23 9.75l-5.5 4.787L18.336 24 12 20.201 5.664 24 7.5 14.537 2 9.75l7.332-1.732z"/></svg>
          <svg id="s2" class="star" viewBox="0 0 24 24"><path fill="#f6c200" d="M12 .587l3.668 7.431L23 9.75l-5.5 4.787L18.336 24 12 20.201 5.664 24 7.5 14.537 2 9.75l7.332-1.732z"/></svg>
          <svg id="s3" class="star" viewBox="0 0 24 24"><path fill="#f6c200" d="M12 .587l3.668 7.431L23 9.75l-5.5 4.787L18.336 24 12 20.201 5.664 24 7.5 14.537 2 9.75l7.332-1.732z"/></svg>
        </div>
      </div>
    </header>

    <div class="panel" id="menuPanel">
      <div style="display:flex;gap:8px;justify-content:center">
        <button class="btn" data-level="1">Level 1 — Guided (fractions)</button>
        <button class="btn" data-level="2">Level 2 — Whole-number slopes</button>
        <button class="btn" data-level="3">Level 3 — Zero / Undefined</button>
      </div>
    </div>

    <div class="panel">
      <div id="directions">Directions will appear here</div>
      <div id="bullets"></div>
      <div id="hint"></div>
    </div>

    <div id="gridWrap" class="panel">
      <canvas id="gameCanvas" width="940" height="720" tabindex="0"></canvas>
    </div>

    <div class="controls panel">
      <button id="nextBtn" class="btn">Next Level ➜</button>
      <button id="newBtn" class="btn">New Problem</button>
      <button id="resetBtn" class="btn">Reset</button>
      <div class="small" style="margin-left:12px">Controls: arrow keys (rise first each cycle)</div>
    </div>

    <div id="result" class="good"></div>
    <footer>Tip: Click canvas to focus. Grid labeled from −10 to 10.</footer>
  </div>

<script>
/* Rowboat Slope Adventure — Final Level 1–3
   - Uses embedded SVG images (data URIs) for high-quality vector graphics (fast & small)
   - Level rules implemented per user spec:
       * Level 1: simplified fractional slopes only (rise/run with gcd=1, run != 1)
       * Level 2: whole-number slopes (run = 1), show fraction and integer
       * Level 3: zero or undefined slopes; dashed path initially
   - Stair path fixed; island placed at its end
   - Directions reflect per-step rise/run (not totals)
   - No reducible rise/run pairs (we ensure simplified pairs)
   - Coconuts fall down & bounce; lower-pitched sounds
   - Stars track successes; auto-advance after 3 successes; Next button for manual advance
*/

// Basic canvas & grid config
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize(){
  DPR = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

// Grid math
const GRID_RANGE = 10;
const P = 64;
function gridToPixel(gx, gy){
  const W = canvas.clientWidth, H = canvas.clientHeight;
  const gw = W - P*2, gh = H - P*2;
  const px = P + ((gx + GRID_RANGE) / (2*GRID_RANGE)) * gw;
  const py = P + (1 - ((gy + GRID_RANGE) / (2*GRID_RANGE))) * gh;
  return {x:px, y:py};
}

// Embedded SVG images as data URIs (these are SVGs embedded; you asked for PNG but SVGs are faster and crisp)
const boatSVG = encodeURIComponent(`
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 100'>
  <defs>
    <linearGradient id='g1' x1='0' x2='1'><stop offset='0' stop-color='#c07a35'/><stop offset='1' stop-color='#7a3f11'/></linearGradient>
    <linearGradient id='s1' x1='0' x2='0' y1='0' y2='1'><stop offset='0' stop-color='#fff'/><stop offset='1' stop-color='#fff9c4'/></linearGradient>
    <filter id='sh'><feDropShadow dx='0' dy='4' stdDeviation='6' flood-color='#000' flood-opacity='0.12'/></filter>
  </defs>
  <g filter='url(#sh)'>
    <ellipse cx='100' cy='83' rx='62' ry='14' fill='rgba(0,0,0,0.08)'/>
    <path d='M30 44 Q100 86 170 44 Q150 30 130 26 Q100 40 70 26 Q50 30 30 44 Z' fill='url(#g1)' stroke='#5a2f10' stroke-width='1.5'/>
    <rect x='82' y='46' width='36' height='10' rx='3' fill='#ffdca8' stroke='#d4a36a'/>
    <circle cx='100' cy='36' r='8' fill='#ffdbb4' stroke='#a86b42'/>
    <rect x='88' y='42' width='24' height='8' rx='3' fill='#0369a1'/>
    <path d='M146 54 L190 64' stroke='#7a3f11' stroke-width='6' stroke-linecap='round'/>
    <path d='M100 12 L100 -6' stroke='#7a3f11' stroke-width='3' stroke-linecap='round'/>
    <path d='M100 0 L120 14 L100 14 Z' fill='url(#s1)' stroke='#d1c7a8'/>
  </g>
</svg>
`);
const islandSVG = encodeURIComponent(`
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 240 160'>
  <defs>
    <radialGradient id='sand' cx='50%' cy='35%' r='60%'><stop offset='0' stop-color='#fff1b9'/><stop offset='1' stop-color='#f7d07a'/></radialGradient>
    <linearGradient id='trunk' x1='0' x2='0' y1='0' y2='1'><stop offset='0' stop-color='#8d6e63'/><stop offset='1' stop-color='#5d4037'/></linearGradient>
  </defs>
  <g>
    <ellipse cx='120' cy='130' rx='80' ry='18' fill='rgba(0,0,0,0.06)'/>
    <ellipse cx='120' cy='110' rx='72' ry='34' fill='url(#sand)' stroke='#d3a94f' stroke-width='1.4'/>
    <path d='M150 48 Q132 6 118 44' stroke='url(#trunk)' stroke-width='12' stroke-linecap='round' fill='none'/>
    <ellipse cx='98' cy='36' rx='30' ry='14' fill='#16a34a'/>
    <ellipse cx='128' cy='20' rx='30' ry='14' fill='#16a34a'/>
    <ellipse cx='162' cy='40' rx='30' ry='14' fill='#16a34a'/>
    <circle cx='110' cy='54' r='6' fill='#6b3f1f'/>
    <circle cx='126' cy='56' r='6' fill='#6b3f1f'/>
  </g>
</svg>
`);

const boatURI = 'data:image/svg+xml;utf8,' + boatSVG;
const islandURI = 'data:image/svg+xml;utf8,' + islandSVG;
const boatImg = new Image();
const islandImg = new Image();
boatImg.src = boatURI;
islandImg.src = islandURI;

// WebAudio: lower pitched thunk + bounce
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
function playImpactSound(){
  try{
    const now = audioCtx.currentTime;
    // low thunk
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(50, now); o.frequency.exponentialRampToValueAtTime(35, now + 0.12);
    g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.28, now + 0.02); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
    o.connect(g); g.connect(audioCtx.destination); o.start(now); o.stop(now + 0.6);
    // small bounce click
    const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
    o2.type = 'triangle'; o2.frequency.setValueAtTime(90, now + 0.06); o2.frequency.exponentialRampToValueAtTime(50, now + 0.16);
    g2.gain.setValueAtTime(0.0001, now + 0.06); g2.gain.linearRampToValueAtTime(0.06, now + 0.08); g2.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o2.connect(g2); g2.connect(audioCtx.destination); o2.start(now + 0.06); o2.stop(now + 0.25);
  }catch(e){}
}
function playSuccessMelody(){
  try{
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type='triangle'; o.frequency.setValueAtTime(100, now); o.frequency.linearRampToValueAtTime(200, now + 0.12);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now + 0.02); g.gain.linearRampToValueAtTime(0.0001, now + 0.6);
    o.connect(g); g.connect(audioCtx.destination); o.start(now); o.stop(now + 0.6);
  }catch(e){}
}

// Game state
let level = 1;
let startBoat;     // grid coords integer
let boat;          // current grid coords
let island;        // grid coords
let stairPoints = [];
let showStairs = true;
let rise = 3, run = 2, cycles = 3;
let inRisePhase = true;
let remainingRise = 0, remainingRun = 0;
let riseErrors = 0, runErrors = 0;
let successes = 0; // star count for current level
let attempts = 0;
let boatDraw; // fractional pos when animating
let animating = false;
let coconuts = []; // for pixel animation
let showLinear = false;

// UI refs
const levelBadge = document.getElementById('levelBadge');
const dirBox = document.getElementById('directions');
const bulletsBox = document.getElementById('bullets');
const hintBox = document.getElementById('hint');
const resultBox = document.getElementById('result');
const nextBtn = document.getElementById('nextBtn');
const newBtn = document.getElementById('newBtn');
const resetBtn = document.getElementById('resetBtn');
const stars = [document.getElementById('s1'), document.getElementById('s2'), document.getElementById('s3')];

// Level select handlers
document.querySelectorAll('#menuPanel .btn').forEach(b=>{
  b.addEventListener('click', ()=>{ setLevel(parseInt(b.dataset.level)); startProblem(); });
});
nextBtn.addEventListener('click', ()=>{ advanceLevel(true); });
newBtn.addEventListener('click', ()=>{ startProblem(); });
resetBtn.addEventListener('click', ()=>{ resetToStart(); });

function setLevel(n){ level = n; levelBadge.textContent = level; successes = 0; updateStars(); }

// Start or randomize depending on level
function startProblem(){
  clearResult();
  coconuts = [];
  boatDraw = undefined;
  showLinear = false;
  if(level === 1) genLevel1();
  else if(level === 2) genLevel2();
  else genLevel3();
  resetToStart();
  draw();
  canvas.focus();
}

// Reset boat to starting position for that problem
function resetToStart(){
  boat = { x: startBoat.x, y: startBoat.y };
  inRisePhase = true;
  remainingRise = Math.abs(rise);
  remainingRun = Math.abs(run);
  riseErrors = 0; runErrors = 0;
  hintBox.textContent = '';
  draw();
}

// ---------- level generators ----------
// helper gcd
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); if(!b) return a; while(b){ const t=b; b=a%b; a=t; } return a; }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// Level 1: simplified fractional slopes only: rise,run ∈ {2,3,4} and gcd(rise,run)=1; run != 1
function genLevel1(){
  // pairing: Q2->Q4 (positive slope) or Q3->Q1 (negative slope)
  const pairing = Math.random() < 0.5 ? 'Q2toQ4' : 'Q3toQ1';
  const startX = randInt(-9, -3);
  const startY = pairing === 'Q2toQ4' ? randInt(3,9) : randInt(-9,-3);
  // choose rise and run from {2,3,4} but ensure gcd=1 and not equal unless 1/1 (not allowed here)
  const pool = [2,3,4];
  let r, s;
  let tries = 0;
  do {
    r = pool[randInt(0,pool.length-1)]; s = pool[randInt(0,pool.length-1)];
    tries++;
    if(tries>50) break;
  } while(gcd(r,s) !== 1 || (r===s)); // avoid reducible and avoid equal numbers
  rise = r; run = s;
  // compute cycles max to keep island inside grid
  let dxMax = Math.floor((10 - startX) / run);
  let dyMax;
  if(pairing === 'Q2toQ4') dyMax = Math.floor((startY + 10) / rise); else dyMax = Math.floor((10 - startY) / rise);
  let maxC = Math.max(1, Math.min(dxMax, dyMax));
  cycles = maxC >=2 ? randInt(2, maxC) : 1;
  if(pairing === 'Q2toQ4') island = { x: startX + cycles*run, y: startY - cycles*rise };
  else island = { x: startX + cycles*run, y: startY + cycles*rise };
  startBoat = { x: startX, y: startY };
  buildStairPoints();
  buildDirections();
}

// Level 2: whole-number slopes: run = 1, rise any integer 1..5, but avoid redundant reducible pairs (not applicable since run=1)
function genLevel2(){
  const pairing = Math.random() < 0.5 ? 'Q2toQ4' : 'Q3toQ1';
  const startX = randInt(-9,-3);
  const startY = pairing === 'Q2toQ4' ? randInt(3,9) : randInt(-9,-3);
  run = 1;
  // pick rise between 1..5, ensure not 0
  rise = randInt(1,5);
  // avoid rise==1 and run==1 causing trivial same? They said rise/run numbers should not be same unless 1/1 allowed: this is okay.
  // compute cycles to fit
  let dxMax = Math.floor((10 - startX) / run);
  let dyMax;
  if(pairing === 'Q2toQ4') dyMax = Math.floor((startY + 10) / rise); else dyMax = Math.floor((10 - startY) / rise);
  let maxC = Math.max(1, Math.min(dxMax, dyMax));
  cycles = maxC >=2 ? randInt(2, maxC) : 1;
  if(pairing === 'Q2toQ4') island = { x: startX + cycles*run, y: startY - cycles*rise };
  else island = { x: startX + cycles*run, y: startY + cycles*rise };
  startBoat = { x:startX, y:startY };
  buildStairPoints();
  buildDirections();
}

// Level 3: zero and undefined slopes. Show dashed start path, convert to solid on success.
function genLevel3(){
  // choose horizontal (zero) or vertical (undefined)
  const mode = Math.random() < 0.5 ? 'horizontal' : 'vertical';
  if(mode === 'horizontal'){
    const startX = randInt(-9,-3);
    const y = randInt(-6,6);
    // choose run 2..6
    run = randInt(2,6); rise = 0;
    cycles = Math.min( Math.floor((10 - startX)/run) || 1, 5);
    island = { x: startX + cycles*run, y: y };
    startBoat = { x: startX, y: y };
  } else {
    const startX = randInt(-9,-3);
    const startY = randInt(-9,-4);
    rise = randInt(2,6); run = 0;
    cycles = Math.min( Math.floor((10 - startY)/rise) || 1, 5);
    island = { x: startX, y: startY + cycles*rise };
    startBoat = { x: startX, y: startY };
  }
  stairPoints = []; // no stairs for pure horizontal/vertical; dashed line will be drawn instead
  buildDirections();
}

// Build fixed stair points from start to island (unit-step)
function buildStairPoints(){
  stairPoints = [];
  let cur = { x: startBoat.x, y: startBoat.y };
  stairPoints.push({...cur});
  const dxSign = Math.sign(island.x - startBoat.x) || 1;
  const dySign = Math.sign(island.y - startBoat.y) || 1;
  for(let c=0;c<cycles;c++){
    for(let s=0;s<Math.abs(rise);s++){
      cur = { x: cur.x, y: cur.y + Math.sign(island.y - startBoat.y) };
      stairPoints.push({...cur});
    }
    for(let s=0;s<Math.abs(run);s++){
      cur = { x: cur.x + Math.sign(island.x - startBoat.x), y: cur.y };
      stairPoints.push({...cur});
    }
  }
  // final adjust
  if(cur.x !== island.x || cur.y !== island.y) stairPoints.push({x:island.x, y:island.y});
}

// Build direction text (per-step numbers)
function buildDirections(){
  bulletsBox.innerHTML = '';
  let riseText = rise === 0 ? '- no rise' : `- rise ${(island.y > startBoat.y) ? 'up' : 'down'} ${Math.abs(rise)} (use the up/down arrow keys to move the boat ${(island.y > startBoat.y) ? 'up' : 'down'} ${Math.abs(rise)} lines)`;
  let runText = run === 0 ? '- no run' : `- run ${(island.x > startBoat.x) ? 'right' : 'left'} ${Math.abs(run)} (then use the left/right arrow keys to move the boat ${(island.x > startBoat.x) ? 'right' : 'left'} ${Math.abs(run)} lines)`;
  bulletsBox.appendChild(document.createElement('div')).textContent = riseText;
  bulletsBox.appendChild(document.createElement('div')).textContent = runText;
  bulletsBox.appendChild(document.createElement('div')).textContent = '- repeat both rise and run movements until the boat reaches the island';
  dirBox.textContent = 'Follow the directions:';
  hintBox.textContent = '';
}

// ---------- drawing ----------
function draw(){
  clear();
  drawBackground();
  drawGrid();
  // dashed path for level 3 zero/undefined at start (if showLinear false)
  if(level === 3 && !showLinear){
    drawDashedPath();
  }
  // stairs for levels 1 & 2
  if(stairPoints && stairPoints.length > 1 && level !== 3) drawStairs();
  if(showLinear) drawLinear();
  drawIsland();
  drawBoat();
  drawCoconuts();
  updateStars();
}

function clear(){ ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight); }
function drawBackground(){
  const W=canvas.clientWidth, H=canvas.clientHeight;
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#e8fbff'); g.addColorStop(1,'#d0f7ff');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}
function drawGrid(){
  const left = P, top = P, right = canvas.clientWidth - P, bottom = canvas.clientHeight - P;
  ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillRect(left, top, right-left, bottom-top);
  const steps = 2*GRID_RANGE;
  ctx.strokeStyle='#e6f2f8'; ctx.lineWidth = 1;
  for(let i=0;i<=steps;i++){
    ctx.beginPath(); ctx.moveTo(left + i*(right-left)/steps, top); ctx.lineTo(left + i*(right-left)/steps, bottom); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(left, top + i*(bottom-top)/steps); ctx.lineTo(right, top + i*(bottom-top)/steps); ctx.stroke();
  }
  // axes
  const origin = gridToPixel(0,0);
  ctx.strokeStyle='#0b3c4a'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(origin.x, top); ctx.lineTo(origin.x, bottom); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(left, origin.y); ctx.lineTo(right, origin.y); ctx.stroke();
  // labels
  ctx.fillStyle='#083344'; ctx.font='12px Arial'; ctx.textAlign='center';
  for(let gx=-GRID_RANGE;gx<=GRID_RANGE;gx++){ const p=gridToPixel(gx,0); ctx.fillText(gx.toString(), p.x, origin.y + 14); }
  ctx.textAlign='right'; for(let gy=-GRID_RANGE; gy<=GRID_RANGE; gy++){ if(gy===0) continue; const p=gridToPixel(0,gy); ctx.fillText(gy.toString(), p.x - 8, p.y + 4); }
}

// draw stairs (fixed)
function drawStairs(){
  if(!stairPoints || stairPoints.length<2) return;
  ctx.strokeStyle='rgba(6,125,150,0.95)'; ctx.lineWidth=4; ctx.setLineDash([]);
  ctx.beginPath();
  for(let i=0;i<stairPoints.length;i++){
    const p = gridToPixel(stairPoints[i].x, stairPoints[i].y);
    if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();
  // markers
  for(const pt of stairPoints){ const p=gridToPixel(pt.x,pt.y); ctx.beginPath(); ctx.fillStyle='rgba(6,125,150,0.95)'; ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }
}

// dashed path for level 3 initial
function drawDashedPath(){
  const p1 = gridToPixel(startBoat.x, startBoat.y);
  const p2 = gridToPixel(island.x, island.y);
  ctx.setLineDash([8,6]);
  ctx.strokeStyle='rgba(14,165,233,0.7)'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke(); ctx.setLineDash([]);
}

// linear solid path on success
function drawLinear(){
  const p1 = gridToPixel(startBoat.x, startBoat.y);
  const p2 = gridToPixel(island.x, island.y);
  ctx.strokeStyle='rgba(14,165,233,0.95)'; ctx.lineWidth = 3; ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
}

// draw island image
function drawIsland(){
  const p = gridToPixel(island.x, island.y);
  const w = 120, h = 80;
  ctx.save(); ctx.translate(p.x - w/2, p.y - h/2);
  if(islandImg.complete) ctx.drawImage(islandImg, 0, 0, w, h);
  ctx.restore();
}

// draw boat (use boatDraw during animation)
function drawBoat(){
  const pos = (boatDraw && boatDraw.x !== undefined) ? boatDraw : boat;
  const p = gridToPixel(pos.x, pos.y);
  const w = 100, h = 50;
  ctx.save(); ctx.translate(p.x - w/2, p.y - h/2);
  if(boatImg.complete) ctx.drawImage(boatImg, 0, 0, w, h);
  ctx.restore();
}

// draw falling coconuts
function drawCoconuts(){
  for(const c of coconuts){
    ctx.beginPath(); ctx.fillStyle='#6b3f1f'; ctx.ellipse(c.px, c.py, c.r, c.r, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.ellipse(c.px-2,c.py-2,2,1.2,0,0,Math.PI*2); ctx.fill();
  }
}

// ---------- movement & rules ----------

// key handling
window.addEventListener('keydown', (e)=>{
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
  canvas.focus();
  if(audioCtx.state === 'suspended') audioCtx.resume();
  if(animating) return;
  if(e.key === 'ArrowUp' || e.key === 'ArrowDown'){ const dy = e.key === 'ArrowUp' ? 1 : -1; tryMove(0, dy); }
  else if(e.key === 'ArrowRight' || e.key === 'ArrowLeft'){ const dx = e.key === 'ArrowRight' ? 1 : -1; tryMove(dx, 0); }
});

// try move in grid units
function tryMove(dx, dy){
  // ignore if success already showing
  if(resultBox.style.display === 'block') return;
  const tx = boat.x + dx, ty = boat.y + dy;
  if(tx < -GRID_RANGE || tx > GRID_RANGE || ty < -GRID_RANGE || ty > GRID_RANGE){ setHint('Out of grid bounds'); return; }
  // level 3 special: pure horizontal or vertical allowed and dashed->solid behavior
  if(level === 3 && (run === 0 || rise === 0)){
    if(run === 0){ // vertical-only
      if(dx !== 0){ setHint('This level is vertical only. Use ↑ or ↓'); return; }
      const want = Math.sign(island.y - startBoat.y) || 1;
      if(Math.sign(dy) !== want){ setHint('Move in the correct vertical direction.'); return; }
      animateTo(tx, ty, ()=>{ checkArrival(); });
      return;
    } else { // horizontal-only
      if(dy !== 0){ setHint('This level is horizontal only. Use ← or →'); return; }
      const want = Math.sign(island.x - startBoat.x) || 1;
      if(Math.sign(dx) !== want){ setHint('Move in the correct horizontal direction.'); return; }
      animateTo(tx, ty, ()=>{ checkArrival(); });
      return;
    }
  }

  // For stairs enforcement (levels 1 & 2)
  if(inRisePhase){
    if(dx !== 0){ runErrors++; if(runErrors>=2) setHint('Finish the rise first (use ↑ or ↓).'); setStatus('Do the rise movement first (use ↑ or ↓).', true); return; }
    // must move in correct vertical direction relative to starting boat
    const want = Math.sign(island.y - startBoat.y) || 1;
    if(Math.sign(dy) !== want){ riseErrors++; if(riseErrors>=2) setHint('Move in the correct vertical direction for the rise.'); setStatus('Wrong vertical direction for the rise.', true); return; }
    // ensure this grid cell is on stair path
    if(!isOnStair(tx,ty)){ setStatus('That move would leave the stair path.', true); return; }
    animateTo(tx,ty, afterVertical);
  } else {
    if(dy !== 0){ setStatus('Now do the run horizontally (use ← or →).', true); return; }
    const wantH = Math.sign(island.x - startBoat.x) || 1;
    if(Math.sign(dx) !== wantH){ runErrors++; if(runErrors>=2) setHint('Move in the correct horizontal direction for the run.'); setStatus('Wrong horizontal direction for the run.', true); return; }
    if(!isOnStair(tx,ty)){ setStatus('That move would leave the stair path.', true); return; }
    animateTo(tx,ty, afterHorizontal);
  }
}

function isOnStair(x,y){
  if(!stairPoints || stairPoints.length===0) return false;
  return stairPoints.some(p => p.x === x && p.y === y);
}

function afterVertical(){
  remainingRise = Math.max(0, remainingRise - 1);
  setStatus(`Rise remaining: ${remainingRise}`);
  if(remainingRise <= 0){
    inRisePhase = false;
    remainingRun = Math.abs(run);
    setStatus(`Now do the run: ${Math.abs(run)} step(s) horizontally.`);
  }
}
function afterHorizontal(){
  remainingRun = Math.max(0, remainingRun - 1);
  setStatus(`Run remaining: ${remainingRun}`);
  if(remainingRun <= 0){
    // reset cycle unless at island
    inRisePhase = true;
    remainingRise = Math.abs(rise);
    attempts++;
    checkArrival();
    if(!(boat.x === island.x && boat.y === island.y)){
      setStatus('Repeat the rise then run sequence until you reach the island.');
    }
  }
}

function checkArrival(){
  if(boat.x === island.x && boat.y === island.y){
    onSuccess();
  }
}

// animate fractional movement for the boat
function animateTo(tx, ty, cb){
  animating = true;
  const sx = boat.x, sy = boat.y;
  const frames = 12; let t=0;
  function step(){
    t++;
    const f = easeOutCubic(t/frames);
    boatDraw = { x: sx + (tx - sx)*f, y: sy + (ty - sy)*f };
    draw();
    if(t < frames) requestAnimationFrame(step);
    else {
      boat = { x: tx, y: ty };
      boatDraw = undefined;
      animating = false;
      draw();
      if(cb) cb();
    }
  }
  requestAnimationFrame(step);
}
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

// ---------- success sequence ----------
function onSuccess(){
  showLinear = true; // show solid line
  playSuccessMelody();
  spawnCoconuts();
  // IMPORTANT: feedback must show per-step rise and run numbers not total displacement
  // display simplified per-step fraction and if level2 whole-number, show equality to integer
  let fracText;
  if(level === 3){
    if(run === 0) fracText = `Rise = ${Math.abs(rise)}, Run = 0 → Slope = ${Math.abs(rise)}/0 = Undefined`;
    else if(rise === 0) fracText = `Rise = 0, Run = ${Math.abs(run)} → Slope = 0/${Math.abs(run)} = 0`;
  } else {
    // per-step rise/run (signed depending on direction)
    const stepRise = (island.y > startBoat.y) ? Math.abs(rise) : -Math.abs(rise);
    const stepRun = (island.x > startBoat.x) ? Math.abs(run) : -Math.abs(run);
    fracText = `Rise = ${Math.abs(rise)}, Run = ${Math.abs(run)} → Slope = ${Math.abs(rise)}/${Math.abs(run)}`;
  // Level 2 show simplification to integer 2/1 = 2
    if(level === 2 && Math.abs(run) === 1){
  // Determine slope sign
  const negative = (island.y > startBoat.y && island.x < startBoat.x) ||
                   (island.y < startBoat.y && island.x > startBoat.x);
  const sign = negative ? '-' : '';
  const signedRise = negative ? -Math.abs(rise) : Math.abs(rise);
  const val = Math.abs(rise) / Math.abs(run);
  // Show negative signs before rise and slope if needed
  fracText = `Rise = ${signedRise}, Run = ${Math.abs(run)} → Slope = ${sign}${Math.abs(rise)}/${Math.abs(run)} = ${sign}${val}`;
} else {
      // For level1 fraction is simplified by construction; show only fraction (no decimals)
      // If negative slope, show negative sign before fraction
      if(stepRise < 0 && stepRun > 0) fracText = `Rise = -${Math.abs(rise)}, Run = ${Math.abs(run)} → Slope = -${Math.abs(rise)}/${Math.abs(run)}`;
      else if(stepRise > 0 && stepRun < 0) fracText = `Rise = ${Math.abs(rise)}, Run = ${Math.abs(run)} → Slope = -${Math.abs(rise)}/${Math.abs(run)}`;
    }
  }
  // show result
  resultBox.textContent = `Great rowing! ${fracText}`;
  resultBox.className = 'good';
  resultBox.style.display = 'block';
  successes = Math.min(3, successes + 1);
  updateStars();
  // auto-advance after 3 successes
  if(successes >= 3){
    setTimeout(()=>{ advanceLevel(true); }, 6000);
  }
}

// spawn cocoa: fall down and bounce; coconuts in pixel space
function spawnCoconuts(){
  coconuts = [];
  const treeTop = gridToPixel(island.x, island.y + 1.2); // just above tree
  for(let i=0;i<3;i++){
    coconuts.push({
      px: treeTop.x + (i-1)*14,
      py: treeTop.y - 8,
      vx: (Math.random()-0.5)*12,
      vy: 40 + Math.random()*30,
      r: 8, landed:false
    });
  }
  const start = performance.now();
  function step(now){
    const t = (now - start)/1000;
    for(const c of coconuts){
      if(!c.landed){
        c.vy += 240 * 0.016;
        c.px += c.vx * 0.016;
        c.py += c.vy * 0.016;
        const ground = gridToPixel(island.x, island.y - 0.9).y;
        if(c.py >= ground){
          c.py = ground;
          c.landed = true;
          c.vy = -c.vy * 0.42;
          c.vx *= 0.4;
          playImpactSound();
        }
      } else {
        c.vy += 240 * 0.016;
        c.py += c.vy * 0.016;
        // settle
        if(Math.abs(c.vy) < 2) c.vy = 0;
      }
    }
    draw();
    if((now - start) < 2400) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ---------- helpers ----------
function setStatus(txt, isErr=false){ dirBox.textContent = txt; if(isErr) hintBox.textContent = txt; }
function setHint(txt){ hintBox.textContent = txt; setTimeout(()=>{ if(hintBox.textContent === txt) hintBox.textContent = ''; }, 3000); }
function clearResult(){ resultBox.style.display = 'none'; resultBox.textContent = ''; }
function updateStars(){ for(let i=0;i<3;i++){ if(i<successes) stars[i].classList.add('filled'); else stars[i].classList.remove('filled'); } }
function advanceLevel(manual=false){ if(level < 3) level++; else level = 1; setLevel(level); successes = 0; updateStars(); setTimeout(()=>{ startProblem(); }, 300); }
function setLevel(n){ level = n; document.getElementById('levelBadge').textContent = level; successes = 0; updateStars(); }

// animate boat fractions when images load
boatImg.onload = draw; islandImg.onload = draw;

// Utility: on start choose Level 1
setLevel(1);
startProblem();

// Allow clicking canvas to focus & resume audio
canvas.addEventListener('pointerdown', ()=>{ canvas.focus(); if(audioCtx.state === 'suspended') audioCtx.resume(); });

// Prevent page arrow scroll
window.addEventListener('keydown', (e)=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });

// initial draw
draw();

</script>
</body>
</html>